#!/usr/bin/env python

import os
import math
import logging
import json
from shutil import rmtree
from copy import deepcopy
from typing import Sequence

import fire
import nbformat


# Runtime config filename
RC_FILENAME = '.metis.json'

# initialize logger
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)


def prompt(message, do_this):
  while True:
    resp = input(f"{message} [Y/n] ")
    if resp.lower() in {"", "y"}:
      do_this()
      return
    elif resp.lower() == "n":
      return
    else:
      print("You must respond with either 'y' or 'n'.")


class RuntimeConfig(object):
  def __init__(self, rc):
    self.name = rc['name']
    self.author = rc['author']
    self.author_email = rc['author_email']
    self.author_github_id = rc['author_github_id']
    self.contents = rc['contents']

  @classmethod
  def empty(cls):
    return cls(dict(
      name='Metis',
      author='Author Name',
      author_email='author@email.com',
      author_github_id='',
      contents=[]))

  def export(self, path):
    data = dict(
      name=self.name, 
      author=self.author,
      author_email=self.author_email,
      author_github_id=self.author_github_id,
      contents=sorted(self.contents))
    with open(path, 'w+') as f:
      f.write(json.dumps(data, indent=4))


class Metis(object):
  def __init__(self):
    self._cwd = os.getcwd()
    self._rc_path = os.path.join(self._cwd, RC_FILENAME)
    if os.path.exists(self._rc_path):
      with open(self._rc_path, 'r') as f:
        self._rc = RuntimeConfig(json.load(f))
    else:
      self._rc = RuntimeConfig.empty()

  def _generate_nb(self, nb_dir):
    r'''Generate a new Jupyter notebook'''
    title = os.path.basename(nb_dir)  # base name of the directory is always the title
    nb_path = os.path.join(nb_dir, title + '.ipynb')
    title_cell = f"""# {title}\n**{self._rc.author}**  \n{self._rc.author_email}"""
    nb = nbformat.v4.new_notebook()
    nb['cells'] = [
      nbformat.v4.new_markdown_cell(title_cell),
      nbformat.v4.new_code_cell(source="# ADD IMPORT STATEMENTS HERE")]
    nbformat.write(nb, nb_path)

  def config(self, author=None, author_email=None, author_github_id=None): 
    if author is not None:
      self._rc.author = str(author)
    if author_email is not None:
      # TODO: check if the argument email is really an email
      self._rc.author_email = str(author_email)
    if author_github_id is not None:
      # TODO: this is temporary
      # this functionality should be a little more sophisticated, e.g.,
      # instead of simply adding a github ID, we'll make the user authorize
      # via a proper API for Github
      self._rc.author_github_id = str(author_github_id)
    self._rc.export(self._rc_path)

  def _nbviewer_link(self, nb_name):
    converted = nb_name.replace(' ', '%20')
    return (f'https://nbviewer.jupyter.org/github/{self._rc.author_github_id}/'
            f'{self._rc.name}/blob/master/{converted}/{converted}.ipynb')

  def readme(self):
    r"""Generate a new `README.md` file from the list of contents"""
    def overwrite():
      with open(readme_path, 'w+') as f:
        contents = self._readme_contents()
        f.write(f'# {self._rc.name}\n'
                f'**{self._rc.author}**  \n'
                f'({self._rc.author_email})\n'
                f'\n'
                f'## Contents\n'
                f'Notebook | Cells\n'
                f'-------- | ----------------------\n'
                f'{contents}')
    readme_path = os.path.join(self._cwd, 'README.md')
    if os.path.exists(readme_path):
      prompt("README.md already exists. Overwrite?", overwrite)
    else:
      overwrite()
  
  def _readme_contents(self):
    lines = []
    for nb_name in self._rc.contents:
      link = self._nbviewer_link(nb_name)
      nb_path = f'{nb_name}/{nb_name}.ipynb'
      cells = ''.join([':memo:' for _ in range(self._num_cells(nb_path))])
      line = f'[{nb_name}]({link}) | {cells}'
      lines.append(line)
    return '\n'.join(lines)

  def _num_cells(self, nb_path):
    r'''Get the number of cells in the notebook'''
    nb = nbformat.read(nb_path, nbformat.NO_CONVERT)
    return int(math.log(len(nb.cells), 2))

  def create(self, nb_name):
    nb_dir = os.path.join(self._cwd, nb_name)
    if (nb_name in self._rc.contents) ^ os.path.isdir(nb_name):
      logger.error(f"Mismatch between rc file and environment regarding '{nb_name}'")
      logger.error(f"Retry after resolving this conflict!")
      return
    try:
      # NOTE: at this point, we already know if the file already exists,
      # it's not listed in `self._rc.contents`
      print(f"Creating a new notebook '{nb_name}'...")
      os.mkdir(nb_dir) # may raise `FileExistsError`
      self._generate_nb(nb_dir)
    except FileExistsError:
      print("error")
      logger.error(f"'{nb_name}' already exists")
      return

    # append the new notebook to the contents
    self._rc.contents.append(nb_name)
    self._rc.export(self._rc_path)

  def remove(self, nb_name):
    def _remove():
      rmtree(os.path.join(self._cwd, nb_name))
      self._rc.contents.remove(nb_name)
      self._rc.export(self._rc_path)
    if nb_name in self._rc.contents:
      prompt(f"Remove {nb_name}?", _remove)
    else:
      logger.error(f"'{nb_name}' doesn't exist")

  def rename(self, nb_name, new_name):
    # TODO: currently this function assumes that all the names are
    # consistent (user does not rename anything)
    # obviously that won't always be the case... address this later
    if nb_name in self._rc.contents:
      # rename the directory containing it
      try:
        os.rename(nb_name, new_name)
        os.chdir(os.path.join(self._cwd, new_name))
        os.rename(f'{nb_name}.ipynb', f'{new_name}.ipynb')
      except OSError:
        logger.error(f"'{new_name}' already exists")

      # change the title of the notebook
      nb = nbformat.read(f'{new_name}.ipynb', nbformat.NO_CONVERT)
      header_source = nb.cells[0]['source'].splitlines()
      for i, line in enumerate(header_source):
        if line.startswith('# '):
          header_source[i] = line.replace(nb_name, new_name)
      nb.cells[0]['source'] = '\n'.join(header_source)
      nbformat.write(nb, f'{new_name}.ipynb')

      # modify the contents list
      self._rc.contents.remove(nb_name)
      self._rc.contents.append(new_name)
      self._rc.export(self._rc_path)
    else:
      logger.error(f"'{nb_name}' doesn't exist")


if __name__ == '__main__':
  fire.Fire(Metis)

